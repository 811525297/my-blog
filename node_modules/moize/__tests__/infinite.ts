import { sameValueZeroEqual } from 'fast-equals';
import microMemoize from 'micro-memoize';
import moize from '../src';

import type { Moized } from '../index.d';

const foo = 'foo';
const bar = 'bar';
const baz = 'baz';
const _default = 'default';

const method = jest.fn(function (one: string, two: string) {
    return { one, two };
});

const methodDefaulted = jest.fn(function (one: string, two = _default) {
    return { one, two };
});

const memoized = moize.infinite(method);
const memoizedDefaulted = moize.infinite(methodDefaulted);

describe('moize', () => {
    afterEach(() => {
        jest.clearAllMocks();

        memoized.clear();
        memoized.clearStats();

        memoizedDefaulted.clear();
        memoizedDefaulted.clearStats();

        moize.collectStats(false);
    });

    describe('main', () => {
        it('should handle a standard use-case', () => {
            const result = memoized(foo, bar);

            expect(result).toEqual({ one: foo, two: bar });

            expect(method).toHaveBeenCalled();

            method.mockClear();

            let newResult;

            for (let index = 0; index < 10; index++) {
                newResult = memoized(foo, bar);

                expect(newResult).toEqual({ one: foo, two: bar });
                expect(method).not.toHaveBeenCalled();
            }
        });

        it('should handle default parameters', () => {
            const result = memoizedDefaulted(foo);

            expect(result).toEqual({ one: foo, two: _default });

            expect(methodDefaulted).toHaveBeenCalled();

            methodDefaulted.mockClear();

            let newResult;

            for (let index = 0; index < 10; index++) {
                newResult = memoizedDefaulted(foo);

                expect(newResult).toEqual({ one: foo, two: _default });
                expect(methodDefaulted).not.toHaveBeenCalled();
            }
        });

        it('should handle a curried call of options creation', () => {
            const moizer = moize({ isSerialized: true })({ maxSize: 5 })({
                maxAge: 1000,
            });

            expect(moizer).toBeInstanceOf(Function);

            const moized = moizer(jest.fn());

            expect(moized.options).toEqual(
                expect.objectContaining({
                    isSerialized: true,
                    maxAge: 1000,
                    maxSize: 5,
                })
            );
        });

        it('should handle moizing an already-moized function with additional options', () => {
            const moized = moize(memoized, { maxSize: 5 });

            expect(moized.originalFunction).toBe(memoized.originalFunction);
            expect(moized.options).toEqual({
                ...memoized.options,
                maxSize: 5,
            });
        });
    });

    describe('cache manipulation', () => {
        it('should add an entry to cache if it does not exist', () => {
            memoized(foo, bar);

            const value = 'something else';

            memoized.set([bar, foo], value);

            expect(memoized.cacheSnapshot).toEqual({
                keys: [
                    [bar, foo],
                    [foo, bar],
                ],
                size: 2,
                values: [value, { one: foo, two: bar }],
            });
        });

        it('should add an entry to cache and remove the oldest one', () => {
            const singleMemoized = moize(method);

            singleMemoized(foo, bar);

            const value = 'something else';

            singleMemoized.set([bar, foo], value);

            expect(singleMemoized.cacheSnapshot).toEqual({
                keys: [[bar, foo]],
                size: 1,
                values: [value],
            });
        });

        it('should notify of 